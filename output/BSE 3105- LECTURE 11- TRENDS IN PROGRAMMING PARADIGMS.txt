&lt;number&gt;Procedural Programming - ExampleThis is a C procedural program that finds the area of a rectangle:
&lt;number&gt;PROGRAMMING PARADIGMS AND EXAMPLESPROCEDURAL LANGUAGESProcedural languages specify, exactly, the steps required to solve a problem. Each line of code is executed one after the other in sequence.The programmer has to specify exactly what the computer is to do.They use sequence, selection and repetition  constructsIF / ELSE, CASE or SWITCH, FOR ... NEXT,REPEAT ... UNTIL ..., WHILE ... DO ...&lt;number&gt;VCN 9691 COMPUTING
&lt;number&gt;5. PROCEDURAL PARADIGMThese are problem-oriented. i.e. they use terms that are specific to the problem being solved.The instructions used are English-like, which makes it easy for the programmer to write code.ExamplesCOBOL (Common Business Oriented Language)FORTRAN (Formula Translation)ALGOL (Algorithmic Language)BASIC (Beginners’ All-purpose Symbolic Instruction Code)C(Computer Programming)The disadvantage is that it can be difficult to reuse code and to modify solutions when better methods of solution are developed.&lt;number&gt;VCN 9691 COMPUTING
Software paradigms: #2 Myth“There is a programming paradigm appropriate to solve all programming problems.”Reality: paradigms evolve in order to address specific cases, not the general case. Programmers do not survive by &quot;being the fittest&quot;; they survive by &quot;fitting in&quot; and by getting the job done. Likewise, paradigms do not survive by &quot;being the fittest“; they survive by fitting into the larger context of software development.A basic and fundamental paradigm shift From &quot;survival of the fittest&quot;: the programmer is a self-sufficient island. To &quot;survival of those who fit&quot;: the programmer is a connected and active citizen of a culture of learning all paradigms for use.
Event driven programming cont.Uses objects (e.g. forms, buttons, textboxes) as the controls which trigger the eventsUsed to develop: programs that need GUIs, programs that need to be developed quickly (RAPID APPLICATION DEVELOPMENT), applications where the USER is the main focusUsually developed using visual tools and techniques where the interface is developed separately from the codeEvent driven programs can be prototyped very quicklyOften event driven languages have built in wizards/functionality to access advanced facilities quickly (databases, web browsers, drop down menus)You can add components to your event driven language (e.g. a media player, an RSS reader control)
Which programming language to use? Since a task can be solved in different ways (paradigms), the language used to describe the solution differs in abstractions, structures due to the way in which the problem is solved. Choose among alternative ways to express thingsunderstand implementation costsbased on knowledge of what will be done underneathSimulate useful features in languages that lack them.There is no theory that dictates the best paradigm to solve a particular problem. How choose programming language?C vs. Modula-3 vs. C++ for systems programmingFortran vs. APL vs. Ada for numerical computationsAda vs. Modula-2 for embedded systemsCommon Lisp vs. Scheme vs. ML for symbolic data manipulationJava vs. C/CORBA for networked PC programs
Software paradigms: #1 MythThe proper paradigm is not an absolute; it depends upon:The social context of each paradigm (technological) Footprint: How many people use it? Has it been used successfully in similar cases? How many people know how to use it?(software) Legacy: What has been used before? What lessons were learned? What should we do differently? Why should we do it differently? (technological) Infrastructure: What pre-existing resources are there? What new resources are required? How much will they cost? Can we afford it?
Event Driven Programming cont.Event Trigger --&gt; action which gets the program to execute your code e.g. click, mouse_move, etcThe event trigger --&gt; runs a sub procedure / event sub proceduresThe sender: control that triggered the eventThe receiver: usually the event sub procedure. It is told to HANDLE the e.g. click event of the button --&gt; the handlerEvent arguments (eventargs): data that the sender passes to the event sub procedure, e.g. the key that you typed into a textbox
Programming languagesThe language paradigm is a general principles that are used by a programmer to communicate a task/algorithm to a computer. The syntax of the language is a way of specifying what is legal in the phrase structure of the language. Knowing the syntax is analogous to knowing how to spell and form sentences in a natural language like English. However, this doesn’t tell us anything about what the sentences mean. The semantics of a program in that language is the third component. Ultimately, without a semantics, a programming language is just a collection of meaningless phrases; Hence, the semantics is the crucial part of a language.
&lt;number&gt;How to solve a problem in OOPIdentify objects involved in the problemIdentify the capability (functionality) of the objectsIdentify the information (data) kept by the objectsDeduce classes from (1)Generalize the objects found to design the classesIdentify relationship between classesUse the &quot;is-a&quot; and &quot;has-a&quot; rules to help&quot;is-a&quot;: Potential class hierarchy&quot;has-a&quot;: Association between separate classesImplement the classes in incremental fashionImplement method by method
Programming languagesA programming language is a system of signs used to communicate a task/algorithm to a computer, causing the task to be performed and solved. Most computer languages are designed to facilitate certain operations and not others: numerical computation, or text manipulation, or I/O. At the heart of it all is a fundamental question: What does it mean to understand a programming language? What do we need to know to program in a language? There are three crucial components to any language. Language paradigmSyntaxSemantics
Software paradigms: #1 MythsThe Programmer can choose the &quot;one true paradigm&quot; for a project in isolation from other factors. Reality: programming is now a social activity in which the &quot;one true path&quot; is a meaningless concept. Religious wars: Proponents of one paradigm often engage in holy wars.Functional versus imperative programming. Strong versus weak typing.Speed versus robustness. Memory models. High-level versus low-level programming. We must be careful not to descend into this pit.
3. Event driven programmingSub routines / functions / procedures are not executed in a specific order – but according to events that are triggered (usually by a user)E.g. The print button in Word triggers a ‘click’ event which then runs the print procedureDelphi, Visual Basic.Net and Python are all examples of languages that can use event driven programming
Programming languagesA programming language is a system of signs used to communicate a task/algorithm to a computer, causing the task to be performed. Most computer languages are designed to facilitate certain operations and not others: numerical computation, or text manipulation, or I/O. At the heart it all is a fundamental question: What does it mean to understand a programming language? What do we need to know to program in a language? There are three crucial components to any language. Language paradigmSyntaxSemantics
&lt;number&gt;Object Oriented Programming (OOP)OOP is built around the idea of OBJECTS built around the parameters of a CLASSE.g. in the real world, CAR would be a Class we could call upon to build an object that had 4 wheels, registration number, doors etc.Each Class will have CONSTRUCTORS coded so the CLASS knows how to build an object when called.Each Class will have METHODS which are used so any instance of a class can perform tasks such as outputting the details of an object
What is programming?If either part is left out, we are no longer doing programming. Without the technology, we are doing pure mathematics. Without the science, we are doing a craft, i.e., we lack deep understanding. Teaching programming correctly therefore means teaching both the technology (current tools) and the science (fundamental concepts). Knowing the tools prepares the student for the present. Knowing the concepts prepares the student for future developments.
IntroductionEach computation model is based on a simple core language called its kernel language. Computer science books introduce the kernel languages in a progressive way, by adding concepts one by one. This helps us to show the deep relationships between the different models. Often, just adding one new concept makes a world of difference in programming. When stepping from one model to the next, how do we decide on what concepts to add? The main criterium is the creative extension principle. Roughly, a new concept is added when programs become complicated for technical reasons unrelated to the problem being solved. Adding a concept to the kernel language can keep programs simple, if the concept is chosen carefully.
2. Logic ProgrammingLogic programming languages are made of sets of facts and rulesThey are often used to develop AI type systems (e.g. ELIZA – the online therapist)The best known language is Prolog – SWI-Prolog is a an example implementation
Why are there so many?Evolution - learn better ways of doing things over time‘goto’-based control flow (Fortran)structured programming (Pascal, C)object-oriented structure (C++, Java)Special purposesymbolic datacharacter stringslow-level system programmingreasoning, logical relationSocio-economic factors: proprietary interestscommercial advantagePersonal preference : diverse ideas about what is pleasant to useSpecial hardware
&lt;number&gt;8. OBJECT-ORIENTED PARADIGMIn these languages data, and methods of manipulating the data, are kept as a single unit called an object.Object-orientated programs make use of classes.A class is a template for creating objects.Classes include reusable code. A class has the three features data encapsulation, (hiding the internal implementation details of an object from its external view )Inheritance (when a child class is derived from the parent class, the child class would contain all the properties (attributes) and methods (operations) of the parent class )polymorphism.(when two or more classes that are inherited from a parent class, implementing an inherited method differently )Examples of object-orientated programming languages: JAVA, Smalltalk, Eiffel, Etc&lt;number&gt;VCN 9691 COMPUTING
What is programming?Many authors define programming, as a general human activity, to mean the act of extending or changing a system’s functionality. Programming is a widespread activity that is done both by non-specialists  and specialists (computer programmers).Programming as defined above has two essential parts: a technology and its scientific foundation. The technology consists of tools, practical techniques, and standards, allowing us to do programming. The science consists of a broad and deep theory with predictive power, allowing us to understand programming to solve a problem.
IntroductionComputer science defines computation model in terms of concepts that are important to programmers: data types, operations, and a programming language. The term ‘computation model’ makes precise the imprecise notion of ‘programming paradigm’.Sometimes we will use the phrase programming model. This refers to what the programmer needs: the programming techniques and design principles made possible by the computation model.
Brief history: High-level languagesMilestones
Programming paradigmsDifferent methodologies are more suitable for solving certain kinds of problems or applications domains. Same for programming languages and paradigms. Multiparadigm languages allow programmers to use the best tool for a job, admitting that no one paradigm solves all problems in the easiest or most efficient way. Programming paradigms differ in:the concepts and the abstractions used to represent the elements of a program (such as objects, functions, variables, constraints, etc.)the steps that compose a computation (assignation, evaluation, data flow, control flow, etc.).
Person and Student classQ: write the code to create an actual person called Cristiano Ronaldo with the email address cronaldo@gmail.comA: person1 = Person(“Cristiano”, “Ronaldo”, cronaldo@gmail.com)
What is programming?Programming is the step between the system’s specification and a running program that implements it. The step consists of designing the program’s architecture and abstractions and coding them into a programming language. This is a broad view, perhaps broader than the usual connotation attached to the word programming. It covers both programming “in the small” and “in the large” aspects. It covers both (language-independent) architectural issues and (language-dependent) coding issues. It is based more on concepts and their use rather than on any one programming language.
&lt;number&gt;Structured programming (cont)The use of procedures and functions can assist a programming team when a piece of software is being developed in the following waysIndividual expertise of each programmer can be utilizedErrors are far more easily spotted Each procedure or function is much simpler to solve than the original problemIndividual procedures are easier to test than the whole solutionLibrary routines can be utilizedOne procedure can be used multiple timesFunctions are mathematically provable to be correct/faulty
Checks during compilationSyntactically invalid constructsInvalid type conversionsA value is used in the “wrong” context, e.g., assigning a float to an intStatic determination of type information is also used to generate more efficient codeKnow what kind of values will be stored in a given memory region during program executionSome programmer logic errorsCan be subtle: if (a = b) … instead of if (a == b) …
Programming education approachesFoundational calculus approachA foundational calculus reduces programming to a minimal number of elements. The elements are chosen to simplify mathematical analysis, not to aid programmer intuition. This helps theoreticians, but is not particularly useful to practicing programmers. Foundational calculi are useful for studying the fundamental properties and limits of programming a computer, not for writing or reasoning about general applications but for showing how to write computer algorithms.Examples: λ-calculus or  π-calculus
&lt;number&gt; Summary Properties Properties  of a class are declared as private. This is so they cannot be accessed outside the class. Methods (procedures and functions) are public and are written to enable the properties of the class to be accessed from outside the class. A constructor is a special method that is used when a new object is created of that class. When an object is created it has all the methods and variables defined in the class. Encapsulation is a term used to describe the combination of the object and its methods. This promotes separation of the implementation and the interface.  Because the properties of the class are private, you can control changes to the actual object. In addition, you have the flexibility to change the implementation without affecting anything outside the class. This principle is known as information hiding. Inheritance is where one class can inherit methods and properties from another class. This promotes efficiency because code from one class can be reused in its sub-class.style.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibility
1. Imperative programmingPrograms written in a sequence of instructions – the program is executed in order of the programmer designsFortran and Cobol are examples of imperative languagesPascal, C and Ada also use the imperative modelImperative programs work and are manipulated with variables and data structures (e.g. Arrays, records etc)
IntroductionThe concepts are organized in terms of computation models. A computation model is a formal system that defines how computations are done. There are many ways to define computation models.It is important that the computation model should be directly useful to the programmer. Each computation model has its own set of techniques for programming and reasoning about programs. The number of different computation models that are known to be useful which is much smaller than the number of programming languages.
Brief history: High-level languagesFortran – first high-level language in the mid-1950sMachine-independent languageCompiler – system program for translating from high-level language to assembly or machine languageNot one-to-one correspondence between source and target operations.Other languages:Algol 60, COBOL (1959), PL/1 (1964), C (1959-1963), Pascal (1968-1969)LISP (1958), ML (1973)Prolog (1970)Smalltalk (1969-1972), C++ (1983), Java (1995)Modula 2(1978), Ada (1980)
Paradigm adoptionSocial guidelines for paradigm adoptionLearning the language might be something that has to be doneConsider the downsides of adoptionThere is nothing more difficult than swimming against a social river. Consider success and failure stories as evidence, and not as truth. Remember the differences between pattern and ritual. Seek to function via chemistry rather than alchemy.Use the law of the median to your advantage, rather than to your disadvantage.Avoid superfluous divergence from the median use case.
&lt;number&gt;Structured programming (cont)A function or procedure is a sub-program that exists to perform a specific, single task.We can use a function if a single value is returned. If no value or more than one value is being returned we use a procedure.Note: If you are programming in C, C++ or Java, there are ONLY functions and no procedures.You also must indicate what data type the function shall return.. If  a function is not going to return a value, its return type is void. That is, no value is actually returned.
CompilerProgram that translates a source language into a target languageTarget language is often, but not always, the assembly language for a particular machineCompilation process
Programming education approachesKernel language approachIn this approach, a practical language is translated into a kernel language that consists of a small number of programmer-significant elements. The rich set of abstractions and syntax is encoded into the small kernel language.This gives both programmer and student a clear insight into what the language does.The kernel language has a simple formal semantics that allows reasoning about program correctness and complexity. This gives a solid foundation to the programmer’s intuition and the programming techniques built on top of it.
&lt;number&gt;An example of OOP (in JAVA)// sample of 2 classes , one is an application with a main method// and the other is a simple class with 1 instance variable and 3 methods// keep for future reference  package untitled14;  public class student{  protected int age; /*also can make &quot;private“*/  public student(){    age=0;  }  public void setAge(int c){    age=c;  }  public int getAge(){    return age;  } }  package untitled14;  import java.io.*;import javax.swing.*;import java.awt.event.*;import java.awt.*;public class Application1{   public static void main(String args[])    {         //how to create an object...         student shepherd = new student(); /*call to the constructor, creates the object*/         shepherd.setAge(30);         int p = shepherd.getAge();         JOptionPane.showMessageDialog(null,&quot;Age is &quot;+p);         //another option: &quot;JOptionPane.showMessageDialog(null,&quot;Age is &quot;+shepherd.getAge());&quot;         System.exit(0);    }}12
Programming ParadigmsImperative programmingFunctional programmingLogic programmingEvent-driven programmingObject-oriented programmingA programming language can use one or multiple styles
IntroductionOne approach to study computer programming is to study programming languages.But there are a tremendously large number of languages, so large that it is impractical to study them all. How can we tackle this immensity? We could pick a small number of languages that are representative of different programming paradigms. But this gives little insight into programming as a unified discipline.We focus on programming concepts and the techniques to use them, not on programming languages.
Brief history: Assembly languageAssembly language – expressed with mnemonic abbreviations, a less error-prone notation.One-to-one correspondence between mnemonics and machine language instructionsAssembler – system program for translating from mnemonics to machine languageMachine-dependent language – rewrite programs for every new machineDifficult to read and write large programsExample: program in assembly language for the x86style.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibility
Programming education approachesPedagogical approach
Brief history: Machine languageMachine language – the sequence of bits that directly controls a processorAdd, compare, move data from one place to another, and so forth at appropriate times.Example: program in machine language for the x86 (Pentium) instruction set, expressed as hexadecimal numbers.
Bytecode compilationCombine compilation with interpretationIdea: remove inefficiencies of ‘read-eval-print’ loop Bytecodes are conceptually similar to real machine opcodes, but they represent compiled instructions to a virtual machine instead of a real machineSource code statically compiled into a set of bytecodesBytecode interpreter implements the virtual machineVirtual machineruntimeBytecodecompilersourceprogrambytecodesBytecodeinterpreterresult
Programming paradigms: AlternativesImperative(How the prog should do it)Procedural - CBlock-Structured - Pascal, AdaObject-based - AdaObject-oriented - Object-Pascal, C++, JavaParallel Processing - Ada, Pascal-S, Occam, C-LindaDeclarative(what program should do at each level)Logic - PrologFunctional - LISP, SchemeDatabase - SQL
Static vs. Dynamic TypingStatic typingCommon in compiled languages, considered “safer”Type of each variable determined at compile-timeConstrains the set of values it can hold at run-timeDynamic typingCommon in interpreted languagesTypes are associated with a variable at run-time; may change dynamically to conform to the type of the value currently referenced by the variableType errors not detected until a piece of code is executed
Functional cont.5! (5 factorial) = 5 * 4 * 3 * 2 * 1In Haskell this looks like:Let fac n = if n == 0 then 1 else n * fac (n-1)This looks nasty but what it does:Let fac n = ...create a function called fac (based on input n)If n == 0 then... If n is 0 then1 ... Return n = 1Else n * fac (n-1) ... Otherwise return n * fac (n-1). Fac(n-1) actually calls the function fac again – but this time with n – 1So what happens if you input: fac 5 ?Is n == 0? No – go to the else condition5 * fac (5-1) – call fac 4Is n == 0? No – go to the else condition4 * fac (4-1) – call fac 3Is n == 3? No – go to the else condition3 * fac (3 – 1) – call fac 2So we’ll end up with: 5 * (5-1) * (4-1) * (3-1) * (2-1) * (1-1) * 1 (because n==0)The 1 finishes the algorithm because it doesn’t call itself anymoreAn algorithm that calls itself is known as a recursive algorithm and we’ll look at them in more detail later on
Object oriented programmingForget about computers for a momentA class: carProperties: colour, size, number of wheelsMethods: (things it can do) drive, accelerate, brake, crash (ok, not really)How do you create a new car from the car class?You instantiate it – or in English, you create a new car objectThe new car object (banger) inherits all of the properties and methods of the car class – the process is called inheritanceBack to programming:There’s a class in VB called the button classWhat properties might it have?What methods might it have?When you create a new button object (btngo) you __________ itWhen you create btngo what does it get? What’s that called?
Pedagogical approachThe logic-based approach presents programming as a branch of mathematical logic.Logic does not speak of execution but of program properties, which is a higher level of abstraction. Programs are mathematical constructions that obey logical laws. The formal semantics of a program is given in terms of a mathematical logic. Reasoning is done with logical assertions.The logic-based approach is harder for students to grasp yet it is essential for defining precise specifications of what programs do.
Session 3 OutlineTo understand the inheritance relationshipCreate and use inheritanceExamples Used: Person StudentsTeacherHOD&#9;&#9;&#9;
Programming education approachesHow can we separate the languages’ fundamental concepts, which underlie their success, from their historical accidents?Practical programming languages provide a rich set of abstractions and syntax.They scale up to programs of millions of lines of code that have to be defined.Four main approachesKernel languageFoundational calculusVirtual machineMultiparadigm language
Trends in Programming ParadigmsProgramming Paradigms
Questions ?
&lt;number&gt;1. LOW-LEVEL PROGRAMMING PARADIGM (CONT)To make programming easier, assembly languages were developed.Binary functions are replaced by mnemonicsMemory addresses are replaced by labels.Assembly language is hard to debug and is so prone to errors.One example of an assembly programming language is MASM (Microsoft Assembler)&lt;number&gt;VCN 9691 COMPUTING
Programming paradigmsExamples
Recap: Classes and ObjectsOOP attempts to simulate the real world by means of objects which have characteristics and functionsA class is a combination of variables, called attributes, and procedures, called methods, forming a self-contained programming entityAn object is one instance of the class definition.The class definition is the blueprint or template that we useClasses are accessed via their methods, not directly.This means that OOP classes can be reused in many different programs without us needing to know how they work.
Software paradigmsParadigm (a Greek word meaning example) is commonly used to refer to a category of entities that share a common characteristic. Computer science distinguish three different kinds of software paradigms:Programming Paradigm: It is a model of how programmers communicate calculation to computers Software Design Paradigm: It is a model for implementing a group of applications sharing common properties Software Development Paradigm: It is often referred to as Software Engineering, may be seen as a management model for implementing big software projects using engineering principles. style.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibility
Object oriented programming cont.Step 1: Name the class.Step 2: Decide on the properties of the class.Step 3: Declare properties as private.Step 4: Declare the constructor of the class. A constructor is procedure that is automatically invoked when an object is first instantiated (created from the class). In VB this is done for you automatically – but not in most languages!Step 5: Declare the methods (procedures and &#9; functions).Step 6: Write the code for your methods.
What makes a language successful?Expressive powerEasy to express things, to use once fluent (C, APL, Algol-68, Perl)Ease of use for noviceEasy to learn (BASIC, Pascal, LOGO)Ease of implementation BASIC, ForthStandardization C, JavaOpen sourceWide dissemination without cost (Pascal, Java)Excellent compilersPossible to compile to very good (fast/small) code (Fortran)Patronage Backing of a powerful sponsor (COBOL, PL/1, Ada, Visual Basic)
&lt;number&gt;4. DECLARATIVE PROGRAMMING PARADIGMSIn this paradigm, the computer is told what the problem is but it doesn’t have the steps necessary to solve the problem.A program written in a declarative language searches a database according to a set of rules supplied to it and produces the results. An example of a declarative programming language is Prolog.&lt;number&gt;VCN 9691 COMPUTING
Evaluation criteria: ReliabilityType checkingTesting for type errorsException handlingIntercept run-time errors and take corrective measuresAliasingPresence of two or more distinct referencing methods for the same memory locationReadability and writabilityA language that does not support “natural” ways of expressing an algorithm will necessarily use “unnatural” approaches, and hence reduced reliability
Evaluation criteria: WritabilitySimplicity and orthogonalityFew constructs, a small number of primitives, a small set of rules for combining themSupport for abstractionThe ability to define and use complex structures or operations in ways that allow details to be ignoredExpressivityA set of relatively convenient ways of specifying operationsExample: the inclusion of for statement in many modern languages
Evaluation criteria: ReadabilityControl statementsThe presence of well-known control structures (e.g., while statement) Data types and structuresThe presence of adequate facilities for defining data structuresSyntax considerationsIdentifier forms: flexible compositionSpecial words and methods of forming compound statementsForm and meaning: self- descriptive constructs, meaningful keywords
Object example : carProperties  Make  Model  Mpg  Engine size  Year of reg  Mileage  Car RegMethods (procedures)  GetCarDetails  UpdateMileage  CalculateAge  Car
Class example : videoProperties (attributes)  Title  Year  Certificate  Genre  VideoID  HirePriceMethods (procedures)  GetVideoDetails  UpdateHirePrice  SetGenre  Video
&lt;number&gt;PROGRAMMING PARADIGMSA programming paradigm is a general approach to programming or to the solution of problems using a programming language.Can also be seen as:A way of thinking about programmingview of a program&lt;number&gt;VCN 9691 COMPUTING
Programming paradigmExamples of multiparadigm languages: Imperative + OO paradigms: C++, Object Pascal, Ada-95, Java;Functional + OO paradigms: Clos;Logic + OO paradigms: Object Prolog.Imperative + OO + Functional paradigms: Common Lisp.Generally, a selected programming paradigm defines main property of a software developed by means of a programming language supporting the paradigm. scalability/modifiability integrability/reusability portability performance reliability ease of creation
Language evaluation criteriaMajor criteriaReadability: the ease with which programs can be read and understoodWritability: the ease with which a language can be used to create programsReliability: conformance to specifications (i.e., performs to its specifications under all conditions)OthersCost: the ultimate total costPortability: the ease with which programs can be moved from one implementation to anotherGenerality: the applicability to a wide range of applicationsWell-definedness: the completeness and precision of the language’s official definition
&lt;number&gt;Declarative ProgrammingDeclarative languages tell the computer what is wanted but do not provide the details of how to do itThe system simply consists of a search engine and a database of facts and rules.There are no IF, WHILE, FOR, etc statements.
&lt;number&gt;PROGRAMMING PARADIGMSA programming paradigm is a general approach to programming or to the solution of problems using a programming language.Can also be seen as:A way of thinking about programmingview of a program&lt;number&gt;VCN 9691 COMPUTING
A basic OOP class in PascalStep 1: Create the class (As a type)Step 2: Declare properties as private.Step 4:  Create the public methods(procedures and functions), including the constructorStep 5: Create the class functionsand proceduresstyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibility
Programming paradigmProgramming paradigm is a fundamental style of computer programming. Compare with a software development methodology, which is a style of solving specific software engineering problems.Programming paradigm is a model for a class of programming languages that share a set of common characteristics. Some languages are designed to support one particular paradigm Smalltalk supports object-oriented programmingHaskell supports functional programmingOther programming languages support multiple paradigms Object Pascal, C++, C#, Visual Basic, Common Lisp, Scheme, Perl, Python, Ruby, Oz and F#.
Evaluation criteria: ReadabilityOverall simplicityA manageable set of features and constructsFew feature multiplicity (means of doing the same operation)Minimal operator overloadingOrthogonalityA relatively small set of primitive constructs can be combined in a relatively small number of waysEvery possible combination is legalLack of orthogonality leads to exceptions to rulesMakes the language easy to learn and readMeaning is context independent
&lt;number&gt;Declarative programming - ExampleFor example, using Prolog, suppose the database is female(jane). female(anne). female(sandip). male(charnjit). male(jaz). male(tom). The query  male(X) will return X = charnjit X = jaz X = tomNotice that the user does not have to tell Prolog how to search for the values of X that satisfy the query.
Multiple InstancesWe can create multiple objects from the same classWe would like to personalise the welcome message for different people  Do you think this is an efficient method?style.visibilitystyle.visibilitystyle.visibility
Pedagogical approachThe computation-based approach presents programming as a way to define executions on machines.It grounds the student’s intuition in the real world by means of actual executions on real systems. This is especially effective with an interactive system: the student can create program fragments and immediately see what they do. Reduces the time between thinking “what if” and seeing the result which is an enormous aid to understanding. Precision is not sacrificed, since the formal semantics of a program can be given in terms of an abstract machine.
Programming languagesThe language paradigm is a general principles that are used by a programmer to communicate a task/algorithm to a computer. The syntax of the language is a way of specifying what is legal in the phrase structure of the language. Knowing the syntax is analogous to knowing how to spell and form sentences in a natural language like English. However, this doesn’t tell us anything about what the sentences mean. The semantics of a program in that language is the third component. Ultimately, without a semantics, a programming language is just a collection of meaningless phrases; Hence, the semantics is the crucial part of a language.
Programming paradigmsImperativeVon Neumann - Fortran, Pascal, Basic, CScripting  - Perl, Python, JavaScript, PHPObject-oriented - Smalltalk, Eiffel, C++DeclarativeFunctional - Scheme, ML, pure Lisp, FPLogic, constraint-based - Prolog, VisiCalc, RPG
Interpretation‘Read-eval-print’ loopRead in an expression, translate into internal formEvaluate internal form This requires an abstract machine and a “run-time” component (usually a compiled program that runs on the native machine)Print the result of evaluationLoop back to read the next expressionREPLinterpreterinputexpressionInterpreterruntimeresult
&lt;number&gt;TYPES OF LANGUAGES AND TYPICAL APPLICATIONSInitially, computers were programmed using binary. This was difficult and led to many errors that were difficult to find. Programs written in binary are said to be written in machine code; This is a very low-level programming paradigm.&lt;number&gt;VCN 9691 COMPUTING1. LOW-LEVEL PROGRAMMING PARADIGM
6. Functional ProgrammingFunctional languages programs define mathematical functionsThere are NO variables or assignment statementsFunctional languages provide MODELS of mathematical functionsThe classic example is HASKELL and the factorial algorithm
Programming domainsScientific applicationsLarge number of floating point computationsLanguage: FortranBusiness applicationsProduce reports, use decimal numbers and charactersLanguage: COBOLArtificial intelligenceSymbols rather than numbers manipulatedLanguage: LISPSystems programmingNeed efficiency because of continuous useLanguage: CWeb ProgrammingEclectic collection of languages: markup (e.g., XHTML), scripting (e.g., PHP), general-purpose (e.g., Java)
User Defined Classes and ObjectsTo define our own class we use the keyword  class Example1: Let us create a definition for Staff objectStep1: Create a class StaffStep2: Let us define a methodgreet () for this class  Outside Class:Step3: Let us create an object from class Staff() (Instantiation)Now run the program and see what happensstyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibility
Pedagogical approachThere are two complementary approaches to teaching programming as a rigorous discipline:The computation-based approach presents programming as a way to define executions on machines.The logic-based approach presents programming as a branch of mathematical logic.
Abstraction and ModularizationRe-use, sharing, extension of code are critically important in software engineeringBig idea: detect errors at compile-time, not when program is executed Type definitions and declarationsDefine intent for both functions/procedures and dataAbstract data types (ADT)Access to local data only via a well-defined interfaceLexical scope
style.visibility
Evaluation criteria: CostTraining programmers to use languageWriting programsCompiling programsExecuting programsLanguage implementation system: availability of free compilersReliability: poor reliability leads to high costsMaintaining programs
&lt;number&gt;Procedural programming - ExampleThe IF /ELSE and CASE or SWITCH constructs are used for selection The FOR..NEXT, WHILE…, DO..WHILE.., and REPEAT..UNTIL are all used for iteration.E.g.//Checking if a number is positive or negative in C++If(Number &gt; 0)    cout &lt;&lt; &quot;The number is positive.&quot;; ELSE {    IF (Number = = 0)    cout &lt;&lt; &quot;The number is zero.&quot;;    ELSE    cout &lt;&lt; &quot;The number is negative.&quot;; }
Class Diagram
Programming education approachesMultiparadigm language approachA multiparadigm language is a language that encompasses several programming paradigms.The usefulness of a multiparadigm language depends on how well the different paradigms are integrated.Examples: Scheme is both functional and imperative.Leda has elements that are functional, object-oriented, and logical.
Designing abstractionsThe most difficult work of programmers, and also the most rewarding, is not writing programs but rather designing abstractions. Programming a computer is primarily designing and using abstractions to achieve new goals. Usually the same abstraction can be used to solve many different problems. This versatility is one of the key properties of abstractions.Designing abstractions is not always easy.Modern computers contain an enormous number of abstractions, working together in a highly organized manner.Abstractions can be classified into a hierarchy depending on how specialized they are.Example: ‘pencil’ is more specialized than ‘writing instrument’, but both are abstractions.
Programming ParadigmsParadigmKey conceptProgramProgram executionResultImperativeCommand (instruction)Sequence of commandsExecution of commandsFinal state of computer memoryFunctionalFunctionCollection of functionsEvaluation of functionsValue of the main functionLogicPredicateLogic formulas: axioms and a theoremLogic proving of the theoremFailure or Success of provingObject-orientedObjectCollection of classes of objectsExchange of messages between the objectsFinal state of the objects’ statesstyle.visibilitystyle.visibility
Inheritance Diagrams
Programming education approachesVirtual machine approachA virtual machine defines a language in terms of an implementation on an idealized machine. A virtual machine gives a kind of operational semantics, with concepts that are close to hardware. This is useful for designing computers, implementing languages, or doing simulations. It is not useful for reasoning about programs and their abstractions.

There are just four major programming language paradigms: Imperative (Procedural) ParadigmObject-Oriented (OO) ParadigmLogic ParadigmFunctional ParadigmExamples: Imperative paradigm: Algol, Pascal, C, Ada;Functional paradigm: C, Lisp, Refal, Planner, Scheme;Logic paradigm: Prolog;Object-oriented paradigm: Python, Java, Smalltalk, Eiffel.Markup - new major paradigmnot a programming, but used to specify the layout of information in Web documentsExamples: XHTML, XMLProgramming paradigmsstyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibility
Implementation methodsCompilationPrograms are translated into machine language (e.g., Fortran, C, C++)Better performancePure InterpretationPrograms are interpreted by another program known as an interpreter (e.g., Scheme, Haskell, Python …)Greater flexibilityBetter diagnostics (error messages)Byte-code compilerProduces portable bytecode, which is executed on virtual machine (e.g., Java)style.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibilitystyle.visibility
&lt;number&gt;7. Structured or Step-wise (Top-down) ProgrammingThis is where a complex problem is broken down into smaller and smaller sub-problems until all the sub-problems can be solved easily. Take an example of calculating wages of a person paid per hour. You could use the following steps.WagesGet Number of hoursCalculate Gross payCalculate deductionsCalculate net payOutput wage slipCalculate normal wagesCalculate overtimeCalculate taxesCalculate others
Software paradigms: #3 Myth“One should always choose the most recent paradigm; it will be the easiest to use. “Reality: the choice is also based upon other factors, including frequency of adoption and social pressure. &quot;The Magic Show&quot; The internet is full of videos that claim that &quot;you can become a &lt;insert paradigm&gt; programmer in 15 minutes.“This makes good PR, but is incredibly misleading. As long as you follow the steps, you will get the same result. But if you deviate - in any respect - you are likely to accomplish nothing at all. These videos are rituals. So, rituals are useful only as long as all you need to write is a guestbook!
Software paradigms: #4 Myth“If I have a great idea, I can become the next Bill Gates/Steve Jobs/...”Reality: It is about as likely as winning the lottery. If you have a great idea, you can rest assured that at least 1000 other people had the same idea. The difference is whether you do something about it, and whether you&apos;re first to market with the innovation.
&lt;number&gt;Structured programming (cont)We can turn this design into a series of functions and procedures. Lets call our program “Wages”We shall have the following functions and proceduresWages() &#9;GetHours( ) returns an integer in range 0 to 60 &#9;CalculateWages(Hours) returns gross wage &#9;CalculateNormalWages(Hours) returns wage for up to 40 hours &#9;CalculateOvertime(Hours) returns pay for any hours over 40 &#9;CalculateDeductions(GrossWage) returns total deductions &#9;CalculateTax(GrossWage) returns tax due &#9;CalculateOthers(GrossWage) returns other deductions due &#9;CalculateNetWage(GrossWage, Deductions) returns net wage after deductions &#9;Procedure OutputResults(Hours, GrossWage, Tax, Others, Deductions, NetWage) Procedure to print the wage slip
Implementation methodsMixed (Hybrid) approachesSource-to-source translation (early C++  Ccompile)Just-in-time Java compilers convert bytecode into native machine code when first executedstyle.visibilitystyle.visibilitystyle.visibilitystyle.visibility
